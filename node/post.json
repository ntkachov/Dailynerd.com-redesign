[
    {
        "blurb": "So I finally got around to updating the blogging engine and the website. There are a few minor improvements as well as a new redesign. ", 
        "body": "First I added an automatic poster. so now I don't need to go through a huge hastle to update the site. \n\nSecond I made the templating client side. This is a much needed improvment over the old method that did all of that work server side. Now its just bare bones updates from here on out. You get some html once and your done. Cache it and all you ever do from there on out is download posts. (granted posts don't cache so I'll chuck that on my todo list.\n\nAlso all of the cool browser bar stuff from the first engine is gone. There's also no more searching. Ill fix that later.", 
        "tags": "", 
        "time": 1332487876118, 
        "title": "New bloging engine."
    }, 
    {
        "blurb": "For the past while I've been thinking on how to speed up mobile websites. These are some notes that I have to make mobile web faster. ", 
        "body": "<h4> Cache Ajax </h4>\nWhen loading a site it may be useful to cache the Ajax response to html5 local storage. This allows the page to load old content before new content is delivered  resulting in perceived speed improvement (although not an actual speed improvent as we now have to pull from storage before we display new stuff). My current temptation is to start an Ajax request, THEN load cache and finally display what ever we get from the server. \n\nSo far that's all I got. My next thoughts are on how to decrease the latenency between the server and the phone. All that stuff the carriers put in to get the phone to go online ends up adding some odd 300ms to the round-trip time. If i can start the Ajax request early i can get a responce and render it as soon as the phone is ready rather than requesting after we have already rendered.  \n\nMore on this later.\n-Nick ", 
        "tags": "", 
        "time": 1332537754846, 
        "title": "Speeding up mobile (notes)"
    }, 
    {
        "blurb": "<p>There is a horrific lack of good OpenGl ES 2.0 Tutorials on the Internet\nfor Android. I'm going to try to rectify this problem by posting \neach and every step that I've done in my own work. </p>", 
        "body": "<p> Our vertex shader should be changed to look like this:</p>\n<pre><code class=\"cpp\">\n\"attribute vec4 vPosition;\\n\"\n\"attribute vec4 SourceColor;\\n\"\n\"varying vec4 DestinationColor;\\n\"\n\"uniform mat4 modelViewMatrix;\\n\"\n\"void main() {\\n\"\n\"DestinationColor = SourceColor;\\n\"\n\"    gl_Position = modelViewMatrix * vPosition;\\n\"\n\"}\\n\"\n</code> </pre>\n<p>\nvPosition will be the position of our verticies in our world. We are going to pass these in one by one using OpenGl's built in functions. Don't worry its only a couple of lines of code.\n<br>\nSourceColor is the color of each verticie that we pass in. So when we pass in the position of our vert we will we also pass in its color. This will eventually change but for now we want solid coloring on our verts.\n<br>\nDestinationColor is simply going to be piping down SourceColor into our fragment shader. More on this in a bit.\n<br>\nmodelViewMatrix is going to be very important. It will basically tell the shader exactly how we want to draw our geometry. This will be its own section.\n</p>\n<p> GLSL (our shader language) is very similar to C so everything goes into our main function. Inside that main we have two things DestinationColor and gl_Position. I already explained DestinationColor. gl_Position is one of the outputs of the shader. It's how we explain to the graphics card where we think this verticie is. modelViewMatrix is going to linearly transform vPosition so that we can rotate, scale, translate all of the verticies at once. The end result is that we rotate our entire world.</p>\n\n<p>Our fragment shader is a little easier\n<pre><code class=\"cpp\">\n\n\"precision mediump float;\\n\"\n\"varying lowp vec4 DestinationColor;\\n\"\n\"void main() {\\n\"\n\"  gl_FragColor = DestinationColor;\\n\"\n\"}\\n\"\n</code> </pre><p>\nHere we are simply going to pipe DesinationColor as the output color (gl_FragColor). This shader is going to get much more complex by the time I'm done with all these tutorials.</p>\n\n<p>Now that we have our shaders in order we can start filling them out.\nFor the most part we will be dealing with our own code and the code inside setupGraphics() and Render(). Google's shader compilers are actually really good\nfor our purposes so we don't need to really edit anything. </p>\n<p>We need to make sure that the CPU and the graphics card are communicateing properly. And that they both know where certain variables inside our shaders are. We need to find position handles for each variable we will be passing in from the CPU to the GPU. We do this using glGetUniformLocation() and glGetAttributeLocation().\n<br>\nInside setupGraphics() add the following code somewhere AFTER gProgram = createProgram... or else you will get a null pointer error.\n\n<pre><code class=\"cpp\">\nmvp_a_positionHandle = glGetUniformLocation(gProgram, \"modelViewMatrix\");\n\ngvPositionHandle = glGetAttribLocation(gProgram, \"vPosition\");\n_colorSlot = glGetAttribLocation(gProgram, \"SourceColor\");\nglEnableVertexAttribArray(_colorSlot);\n\nLOGI(\"Found MVP Position Handle : %i\", mvp_a_positionHandle);\nLOGI(\"glGetAttribLocation(\\\"vPosition\\\") = %d\\n\",\n            gvPositionHandle);\ncheckGlError(\"glGetAttribLocation\");\nsetupVBO();\n</code> </pre><p>\n\nDon't forget to add some global variable declarations for mvp_a_positionHandle and _colorSlot both are of type GLuint.\n\n\n<br>\n<p>Now that we have the locations of our shader variables we need to initilize them. Since this code will change in the next tutorial go ahead and copy-paste this code ABOVE the setupGraphics() method.\n\n<pre><code class=\"cpp\">\ntypedef struct {<br/>\tfloat Position[3];<br/>\tfloat Color[4];<br/>} Vertex;\n<br>\nconst Vertex Vertices[] = {<br/>\t{{1, -1, 0}, {1, 0, 0, 1}},<br/>\t{{1, 1, 0}, {1, 0, 0, 1}},<br/>\t{{-1, 1, 0}, {0, 1, 0, 1}},<br/>\t{{-1, -1, 0}, {0, 1, 0, 1}},<br/>\t{{1, -1, -1}, {1, 0, 0, 1}},<br/>\t{{1, 1, -1}, {1, 0, 0, 1}},<br/>\t{{-1, 1, -1}, {0, 1, 0, 1}},<br/>\t{{-1, -1, -1}, {0, 1, 0, 1}}<br/>};<br/><br/>const GLubyte Indices[] = {<br/>\t// Front<br/>\t0, 1, 2,<br/>\t2, 3, 0,<br/>\t// Back<br/>\t4, 6, 5,<br/>\t4, 7, 6,<br/>\t// Left<br/>\t2, 7, 3,<br/>\t7, 6, 2,<br/>\t// Right<br/>\t0, 4, 1,<br/>\t4, 1, 5,<br/>\t// Top<br/>\t6, 2, 1, <br/>\t1, 6, 5,<br/>\t// Bottom<br/>\t0, 3, 7,<br/>\t0, 7, 4    <br/>};<br/>void setupVBO(){<br/><br/>\tGLuint vertexBuffer;<br/>\tglGenBuffers(1, &amp;vertexBuffer);<br/>\tglBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);<br/>\tglBufferData(GL_ARRAY_BUFFER, sizeof(Vertices), Vertices, GL_STATIC_DRAW);<br/><br/>\tGLuint indexBuffer;<br/>\tglGenBuffers(1, &amp;indexBuffer);<br/>\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indexBuffer);<br/>\tglBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(Indices), Indices, GL_STATIC_DRAW);<br/>}\n</code> </pre><p>\nThis is simply our cube and indices. But we're not done. We need to set up our vertex buffer objects. These are just going to make it easy to pass vertex data into our shader variables. For now we will copy-paste this code in. Next tutorial we will take a closer look at this and fix this code to handle models.\n<br>\n<pre><code class=\"cpp\">\nvoid setupVBO(){<br/><br/>\tGLuint vertexBuffer;<br/>\tglGenBuffers(1, &amp;vertexBuffer);<br/>\tglBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);<br/>\tglBufferData(GL_ARRAY_BUFFER, sizeof(Vertices), Vertices, GL_STATIC_DRAW);<br/><br/>\tGLuint indexBuffer;<br/>\tglGenBuffers(1, &amp;indexBuffer);<br/>\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indexBuffer);<br/>\tglBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(Indices), Indices, GL_STATIC_DRAW);<br/>}\n</code> </pre>\n<p>\nNow that we have that mess out of the way lets go ahead and set up that Model View Projection Matrix we were talking about. For those that don't know. When we take a vector (such as a coordinate in 3d space) and multiply it by a specific matrix we can move that coordinate into another point in 3d space. If we use the same matrix on a group of coordinates that make up a shape we effectively moved the entire shape around the space. Makeing this Model View Matrix is not simple but is time consumeing. You also need to have a good understanding of Linear Algebra to construct these. Good news though, pleanty of people have created libraries that will do exactly what we need. GLM is one such library and works well with android. \n<br>\n<a href=\"http://glm.g-truc.net/\">Download GLM here</a>\n<br>\nExtract the entire contents of the archive into the jni folder of your project. we need them for this section. \n</p>\n<p>\nThankfully GLM provide us with a Model View Projection Matrix function in their manual. For now this is going to be good enough. Paste these headers into your document \n<br>\n<pre><code class=\"cpp\">\n#include&lt;glm/glm.hpp&gt;<br>\n#include&lt;glm/gtc/matrix_transform.hpp&gt;<br>\n#include&lt;glm/gtc/type_ptr.hpp&gt;<br>\n</code> </pre><p>\nand then add this function somewhere above renderFrame().\n<br><pre><code class=\"cpp\">\nvoid setUniformMVP( GLuint Location, glm::vec3 const &amp; Translate, glm::vec3 const &amp; Rotate )<br/>{<br/>\tglm::mat4 Projection =<br/>\t\tglm::perspective(45.0f, 4.0f / 3.0f, 0.1f, 100.f);<br/>\tglm::mat4 ViewTranslate = glm::translate(<br/>\t\t\tglm::mat4(1.0f),<br/>\t\t\tTranslate);<br/>\tglm::mat4 ViewRotateX = glm::rotate(<br/>\t\t\tViewTranslate,<br/>\t\t\tRotate.y, glm::vec3(-1.0f, 0.0f, 0.0f));<br/>\tglm::mat4 View = glm::rotate(<br/>\t\t\tViewRotateX,<br/>\t\t\tRotate.x, glm::vec3(0.0f, 1.0f, 0.0f));<br/>\tglm::mat4 Model = glm::scale(<br/>\t\t\tglm::mat4(1.0f),<br/>\t\t\tglm::vec3(0.5f));<br/>\tglm::mat4 MVP = Projection * View * Model;<br/>\tglUniformMatrix4fv(<br/>\t\t\tLocation, 1, GL_FALSE, glm::value_ptr(MVP));}\n</code> </pre><p>\n\nThis will create our Model View Projection Matrix for us. But lets look at how it works. The function accepts Location as one of its parameters. This is going to be the location of modelViewMatrix inside our vertex shader. The translate method that it will take it will move our scene around the map. think of this as the offset method that will offset our cube to the left or right some pixels.\nrotate will do exactly what it sounds like. It will rotate our scene by some units in the given directions. </p>\n\n<p>\nNow we put it all together.  Go ahead an erase EVERYTHING in your renderFrame() method. And replace it with this:<br>\n<br><pre><code class=\"cpp\">\n\tglClearColor(0,0,0, 1.0f);<br/>\tcheckGlError(\"glClearColor\");<br/>\tglClear( GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);<br/>\tglEnable(GL_DEPTH_TEST);<br/>\tcheckGlError(\"glClear\");<br/><br/>\tglUseProgram(gProgram);<br/>\tcheckGlError(\"glUseProgram\");<br/><br/>\trotate =0.5f;<br/><br/>\tsetUniformMVP(mvp_a_positionHandle, glm::vec3(0,0,-3), glm::vec3(rotate,0,0));<br/><br/>\tglVertexAttribPointer(gvPositionHandle, 3, GL_FLOAT, GL_FALSE,<br/>\t\t\tsizeof(Vertex), 0);<br/>\tcheckGlError(\"glVertexAttribPointer\");<br/>\tglVertexAttribPointer(_colorSlot, 4, GL_FLOAT, GL_FALSE,<br/>\t\t\tsizeof(Vertex), (GLvoid*) (sizeof(float) * 3));<br/>\tcheckGlError(\"glVertexAttribPointer\");<br/>\tglEnableVertexAttribArray(gvPositionHandle);<br/>\tglDrawElements(GL_TRIANGLES, sizeof(Indices)/sizeof(Indices[0]),<br/>\t\t\tGL_UNSIGNED_BYTE, 0);<br/>\tcheckGlError(\"glDrawElements\");<br>\n<br></code> </pre><p>\n\nThis is the important part so lets go over what it does.<p>\n<p><b>glClearColor(0,0,0,1.0f);</b><br>\nThis simply makes our entire screen black. A good way to check for problems in rendering is to change this to a different color (say red) and see if it renders red. If it doesn't you have a problem with your frame buffers.\n</p>\n<p><b>glClear( GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);</b><br>\nThis tells the gpu to clear the depth buffer as well as the color buffer. \nWithout this we would keep drawing over the previous frame.</p>\n<p><b>glEnable(GL_DEPTH_TEST);</b><br>\nThis actually makes sure that we don't draw stuff in the background as the foreground. Go ahead and comment out this line and try this code without it. You'll see what I mean.</p>\n<p><b>setUniformMVP(mvp_a_positionHandle, glm::vec3(0,0,-3), glm::vec3(rotate,0,0));</b><br>\nThis is the function we added a bit ago. Here we are telling it the location of modelViewMatrix and passing in two vectors. Since the camera is always looking down the negative Z axis we push the scene back down the Z axis to zoom out a little. We also tell it to rotate the entire scene on the X axis.</p>\n<p><b>glVertexAttribPointer(gvPositionHandle, 3, GL_FLOAT, GL_FALSE,<br/>\t\t\tsizeof(Vertex), 0);<br/>\nglVertexAttribPointer(_colorSlot, 4, GL_FLOAT, GL_FALSE,<br/>\t\t\tsizeof(Vertex), (GLvoid*) (sizeof(float) * 3));<br/></b><br>\nThis line we are pointing our where we would like the verticies stored and telling the GPU that our verticies are defined by 3 numbers. We also tell the GPU what our array construction looks like. Each number is a GL_FLOAT and each element in our array is the size of a Vertex (the structure we declaired) and our array starts at 0; The next line does the same thing but for our color information.</p>\n<p><b>lDrawElements(GL_TRIANGLES, sizeof(Indices)/sizeof(Indices[0]),<br/>\t\t\tGL_UNSIGNED_BYTE, 0);<br/></b><br>\nHere is where we actually tell the GPU to draw each individual vert. We tell it to draw triangles and exactly how to draw the triangles. We tell it how to use the indice buffer we passed in. </p>\n<p>Thats it for now. I hope it helps, The next tutorial we will change our simple cube to a more complicated monkey face</p>", 
        "tags": "android opengl", 
        "time": 1334590368135, 
        "title": "Android Native OpenGL 2.0 Tutorial Part 1"
    }, 
    {
        "blurb": "<p>From part 1 we got the default project to work. This time we will go through \na little more and get a spinning cube. </p>\n\n<p>First lets start with our shaders. For now we will leave them hard coded inside the gl_code.cpp. Later on it will be wise to move them into a seperate file. </p>", 
        "body": "<p> Our vertex shader should be changed to look like this:</p>\n<pre><code class=\"cpp\">\n\"attribute vec4 vPosition;\\n\"\n\"attribute vec4 SourceColor;\\n\"\n\"varying vec4 DestinationColor;\\n\"\n\"uniform mat4 modelViewMatrix;\\n\"\n\"void main() {\\n\"\n\"DestinationColor = SourceColor;\\n\"\n\"    gl_Position = modelViewMatrix * vPosition;\\n\"\n\"}\\n\"\n</code> </pre>\n<p>\nvPosition will be the position of our verticies in our world. We are going to pass these in one by one using OpenGl's built in functions. Don't worry its only a couple of lines of code.\n<br>\nSourceColor is the color of each verticie that we pass in. So when we pass in the position of our vert we will we also pass in its color. This will eventually change but for now we want solid coloring on our verts.\n<br>\nDestinationColor is simply going to be piping down SourceColor into our fragment shader. More on this in a bit.\n<br>\nmodelViewMatrix is going to be very important. It will basically tell the shader exactly how we want to draw our geometry. This will be its own section.\n</p>\n<p> GLSL (our shader language) is very similar to C so everything goes into our main function. Inside that main we have two things DestinationColor and gl_Position. I already explained DestinationColor. gl_Position is one of the outputs of the shader. It's how we explain to the graphics card where we think this verticie is. modelViewMatrix is going to linearly transform vPosition so that we can rotate, scale, translate all of the verticies at once. The end result is that we rotate our entire world.</p>\n\n<p>Our fragment shader is a little easier\n<pre><code class=\"cpp\">\n\n\"precision mediump float;\\n\"\n\"varying lowp vec4 DestinationColor;\\n\"\n\"void main() {\\n\"\n\"  gl_FragColor = DestinationColor;\\n\"\n\"}\\n\"\n</code> </pre><p>\nHere we are simply going to pipe DesinationColor as the output color (gl_FragColor). This shader is going to get much more complex by the time I'm done with all these tutorials.</p>\n\n<p>Now that we have our shaders in order we can start filling them out.\nFor the most part we will be dealing with our own code and the code inside setupGraphics() and Render(). Google's shader compilers are actually really good\nfor our purposes so we don't need to really edit anything. </p>\n<p>We need to make sure that the CPU and the graphics card are communicateing properly. And that they both know where certain variables inside our shaders are. We need to find position handles for each variable we will be passing in from the CPU to the GPU. We do this using glGetUniformLocation() and glGetAttributeLocation().\n<br>\nInside setupGraphics() add the following code somewhere AFTER gProgram = createProgram... or else you will get a null pointer error.\n\n<pre><code class=\"cpp\">\nmvp_a_positionHandle = glGetUniformLocation(gProgram, \"modelViewMatrix\");\n\ngvPositionHandle = glGetAttribLocation(gProgram, \"vPosition\");\n_colorSlot = glGetAttribLocation(gProgram, \"SourceColor\");\nglEnableVertexAttribArray(_colorSlot);\n\nLOGI(\"Found MVP Position Handle : %i\", mvp_a_positionHandle);\nLOGI(\"glGetAttribLocation(\\\"vPosition\\\") = %d\\n\",\n            gvPositionHandle);\ncheckGlError(\"glGetAttribLocation\");\nsetupVBO();\n</code> </pre><p>\n\nDon't forget to add some global variable declarations for mvp_a_positionHandle and _colorSlot both are of type GLuint.\n\n\n<br>\n<p>Now that we have the locations of our shader variables we need to initilize them. Since this code will change in the next tutorial go ahead and copy-paste this code ABOVE the setupGraphics() method.\n\n<pre><code class=\"cpp\">\ntypedef struct {<br/>\tfloat Position[3];<br/>\tfloat Color[4];<br/>} Vertex;\n<br>\nconst Vertex Vertices[] = {<br/>\t{{1, -1, 0}, {1, 0, 0, 1}},<br/>\t{{1, 1, 0}, {1, 0, 0, 1}},<br/>\t{{-1, 1, 0}, {0, 1, 0, 1}},<br/>\t{{-1, -1, 0}, {0, 1, 0, 1}},<br/>\t{{1, -1, -1}, {1, 0, 0, 1}},<br/>\t{{1, 1, -1}, {1, 0, 0, 1}},<br/>\t{{-1, 1, -1}, {0, 1, 0, 1}},<br/>\t{{-1, -1, -1}, {0, 1, 0, 1}}<br/>};<br/><br/>const GLubyte Indices[] = {<br/>\t// Front<br/>\t0, 1, 2,<br/>\t2, 3, 0,<br/>\t// Back<br/>\t4, 6, 5,<br/>\t4, 7, 6,<br/>\t// Left<br/>\t2, 7, 3,<br/>\t7, 6, 2,<br/>\t// Right<br/>\t0, 4, 1,<br/>\t4, 1, 5,<br/>\t// Top<br/>\t6, 2, 1, <br/>\t1, 6, 5,<br/>\t// Bottom<br/>\t0, 3, 7,<br/>\t0, 7, 4    <br/>};<br/>void setupVBO(){<br/><br/>\tGLuint vertexBuffer;<br/>\tglGenBuffers(1, &amp;vertexBuffer);<br/>\tglBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);<br/>\tglBufferData(GL_ARRAY_BUFFER, sizeof(Vertices), Vertices, GL_STATIC_DRAW);<br/><br/>\tGLuint indexBuffer;<br/>\tglGenBuffers(1, &amp;indexBuffer);<br/>\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indexBuffer);<br/>\tglBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(Indices), Indices, GL_STATIC_DRAW);<br/>}\n</code> </pre><p>\nThis is simply our cube and indices. But we're not done. We need to set up our vertex buffer objects. These are just going to make it easy to pass vertex data into our shader variables. For now we will copy-paste this code in. Next tutorial we will take a closer look at this and fix this code to handle models.\n<br>\n<pre><code class=\"cpp\">\nvoid setupVBO(){<br/><br/>\tGLuint vertexBuffer;<br/>\tglGenBuffers(1, &amp;vertexBuffer);<br/>\tglBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);<br/>\tglBufferData(GL_ARRAY_BUFFER, sizeof(Vertices), Vertices, GL_STATIC_DRAW);<br/><br/>\tGLuint indexBuffer;<br/>\tglGenBuffers(1, &amp;indexBuffer);<br/>\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indexBuffer);<br/>\tglBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(Indices), Indices, GL_STATIC_DRAW);<br/>}\n</code> </pre>\n<p>\nNow that we have that mess out of the way lets go ahead and set up that Model View Projection Matrix we were talking about. For those that don't know. When we take a vector (such as a coordinate in 3d space) and multiply it by a specific matrix we can move that coordinate into another point in 3d space. If we use the same matrix on a group of coordinates that make up a shape we effectively moved the entire shape around the space. Makeing this Model View Matrix is not simple but is time consumeing. You also need to have a good understanding of Linear Algebra to construct these. Good news though, pleanty of people have created libraries that will do exactly what we need. GLM is one such library and works well with android. \n<br>\n<a href=\"http://glm.g-truc.net/\">Download GLM here</a>\n<br>\nExtract the entire contents of the archive into the jni folder of your project. we need them for this section. \n</p>\n<p>\nThankfully GLM provide us with a Model View Projection Matrix function in their manual. For now this is going to be good enough. Paste these headers into your document \n<br>\n<pre><code class=\"cpp\">\n#include&lt;glm/glm.hpp&gt;<br>\n#include&lt;glm/gtc/matrix_transform.hpp&gt;<br>\n#include&lt;glm/gtc/type_ptr.hpp&gt;<br>\n</code> </pre><p>\nand then add this function somewhere above renderFrame().\n<br><pre><code class=\"cpp\">\nvoid setUniformMVP( GLuint Location, glm::vec3 const &amp; Translate, glm::vec3 const &amp; Rotate )<br/>{<br/>\tglm::mat4 Projection =<br/>\t\tglm::perspective(45.0f, 4.0f / 3.0f, 0.1f, 100.f);<br/>\tglm::mat4 ViewTranslate = glm::translate(<br/>\t\t\tglm::mat4(1.0f),<br/>\t\t\tTranslate);<br/>\tglm::mat4 ViewRotateX = glm::rotate(<br/>\t\t\tViewTranslate,<br/>\t\t\tRotate.y, glm::vec3(-1.0f, 0.0f, 0.0f));<br/>\tglm::mat4 View = glm::rotate(<br/>\t\t\tViewRotateX,<br/>\t\t\tRotate.x, glm::vec3(0.0f, 1.0f, 0.0f));<br/>\tglm::mat4 Model = glm::scale(<br/>\t\t\tglm::mat4(1.0f),<br/>\t\t\tglm::vec3(0.5f));<br/>\tglm::mat4 MVP = Projection * View * Model;<br/>\tglUniformMatrix4fv(<br/>\t\t\tLocation, 1, GL_FALSE, glm::value_ptr(MVP));}\n</code> </pre><p>\n\nThis will create our Model View Projection Matrix for us. But lets look at how it works. The function accepts Location as one of its parameters. This is going to be the location of modelViewMatrix inside our vertex shader. The translate method that it will take it will move our scene around the map. think of this as the offset method that will offset our cube to the left or right some pixels.\nrotate will do exactly what it sounds like. It will rotate our scene by some units in the given directions. </p>\n\n<p>\nNow we put it all together.  Go ahead an erase EVERYTHING in your renderFrame() method. And replace it with this:<br>\n<br><pre><code class=\"cpp\">\n\tglClearColor(0,0,0, 1.0f);<br/>\tcheckGlError(\"glClearColor\");<br/>\tglClear( GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);<br/>\tglEnable(GL_DEPTH_TEST);<br/>\tcheckGlError(\"glClear\");<br/><br/>\tglUseProgram(gProgram);<br/>\tcheckGlError(\"glUseProgram\");<br/><br/>\trotate =0.5f;<br/><br/>\tsetUniformMVP(mvp_a_positionHandle, glm::vec3(0,0,-3), glm::vec3(rotate,0,0));<br/><br/>\tglVertexAttribPointer(gvPositionHandle, 3, GL_FLOAT, GL_FALSE,<br/>\t\t\tsizeof(Vertex), 0);<br/>\tcheckGlError(\"glVertexAttribPointer\");<br/>\tglVertexAttribPointer(_colorSlot, 4, GL_FLOAT, GL_FALSE,<br/>\t\t\tsizeof(Vertex), (GLvoid*) (sizeof(float) * 3));<br/>\tcheckGlError(\"glVertexAttribPointer\");<br/>\tglEnableVertexAttribArray(gvPositionHandle);<br/>\tglDrawElements(GL_TRIANGLES, sizeof(Indices)/sizeof(Indices[0]),<br/>\t\t\tGL_UNSIGNED_BYTE, 0);<br/>\tcheckGlError(\"glDrawElements\");<br>\n<br></code> </pre><p>\n\nThis is the important part so lets go over what it does.<p>\n<p><b>glClearColor(0,0,0,1.0f);</b><br>\nThis simply makes our entire screen black. A good way to check for problems in rendering is to change this to a different color (say red) and see if it renders red. If it doesn't you have a problem with your frame buffers.\n</p>\n<p><b>glClear( GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);</b><br>\nThis tells the gpu to clear the depth buffer as well as the color buffer. \nWithout this we would keep drawing over the previous frame.</p>\n<p><b>glEnable(GL_DEPTH_TEST);</b><br>\nThis actually makes sure that we don't draw stuff in the background as the foreground. Go ahead and comment out this line and try this code without it. You'll see what I mean.</p>\n<p><b>setUniformMVP(mvp_a_positionHandle, glm::vec3(0,0,-3), glm::vec3(rotate,0,0));</b><br>\nThis is the function we added a bit ago. Here we are telling it the location of modelViewMatrix and passing in two vectors. Since the camera is always looking down the negative Z axis we push the scene back down the Z axis to zoom out a little. We also tell it to rotate the entire scene on the X axis.</p>\n<p><b>glVertexAttribPointer(gvPositionHandle, 3, GL_FLOAT, GL_FALSE,<br/>\t\t\tsizeof(Vertex), 0);<br/>\nglVertexAttribPointer(_colorSlot, 4, GL_FLOAT, GL_FALSE,<br/>\t\t\tsizeof(Vertex), (GLvoid*) (sizeof(float) * 3));<br/></b><br>\nThis line we are pointing our where we would like the verticies stored and telling the GPU that our verticies are defined by 3 numbers. We also tell the GPU what our array construction looks like. Each number is a GL_FLOAT and each element in our array is the size of a Vertex (the structure we declaired) and our array starts at 0; The next line does the same thing but for our color information.</p>\n<p><b>lDrawElements(GL_TRIANGLES, sizeof(Indices)/sizeof(Indices[0]),<br/>\t\t\tGL_UNSIGNED_BYTE, 0);<br/></b><br>\nHere is where we actually tell the GPU to draw each individual vert. We tell it to draw triangles and exactly how to draw the triangles. We tell it how to use the indice buffer we passed in. </p>\n<p>Thats it for now. I hope it helps, The next tutorial we will change our simple cube to a more complicated monkey face</p>", 
        "tags": "android opengl ndk", 
        "time": 1334590441668, 
        "title": "Android Native OpenGL 2.0 Tutorial Part 2"
    }, 
    {
        "blurb": "If you tell some poor nerd \"its OK to be weird, it gets better in a few years\" that doesn't change the fact that, for a 14 yo kid, graduation and college seems like a life-time away. But we can do better than \"oh woe is me\". High school doesn't have to be a drag.", 
        "body": "</p><p>\nBut lets be honest, being the odd man out has some perks, as long as you use them to your advantage. \n</p><p>\nFirst, you have no social life. GREAT! Use that free time for something worth while. Learn to program, learn to draw, learn to play video games better and then start a hit online series.  Don't wallow in pity. Get out there and start to do things.\n</p><p>\nOh, lets not forget, no one likes you. Wonderful! So we have nothing to lose. Go out and talk to people. Specifically, who ever you are interested in. That cute girl/boy across from you in biology. Ya. That one. Go ask them out. Whats the worst that could happen? Seriously, learning to talk to people in high school will make you much better off when college starts. Also read \"How to Win Friends and Influence People\" by Dale Carnegie. It will make your life much easier in college and may win you some good friend from high school. Because, who knows, maybe they'll say yes.\n</p><p>\nNext, To all those jerks who keep calling you names, one medium cafe late, extra cream.\n</p><p> Of those people who were making a fool of me in high school, are now making a fool of themselves in college. \"You majored in political science, and your qualifications include, 'Associate' at 'Nick's Coffee and Tea'\" I can imagine their future employers saying, \"Ya, I think we will stick with the guy that did a semester in the senators office\". Their habits in high school of not embracing diversity never offered them the perspective they needed to understand what other people were doing and what their competition looks like. Now, they are stuck because that one nerd from high school, who would spend hours in the debate classroom, who looked so stupid back then, just snagged a job from them. It's not quite, 'keep your friends close and your enemies closer', it's more about sharing common knowledge. A group of different people, with similar interests, will gather different knowledge and can, as a group, determine the state of affairs better than a single person or a group of similar people can. \n</p><p>\nWhich brings me to my final point, join a community. It doesn't matter what community. Be it a Minecraft server, some sub-reddit with a few thousand people, or local, join something. Get out there and expand your own horizons. If you are one of the lucky kids with parent that let you out of the house, go and visit conventions. Otherwise, be a part of something online. It doesn't matter what the community is, how it is structured, or who's in it. As long as its not a single homogeneous body, its good enough.\n\ntl;dr: Get a hobby, Talk to people. </p>", 
        "tags": "", 
        "time": 1335291390807, 
        "title": "High school doesn't have to suck if you're weird. "
    }
]
