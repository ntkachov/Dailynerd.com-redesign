[{"blurb":"So I finally got around to updating the blogging engine and the website. There are a few minor improvements as well as a new redesign. ","body":"First I added an automatic poster. so now I don't need to go through a huge hastle to update the site. \n\nSecond I made the templating client side. This is a much needed improvment over the old method that did all of that work server side. Now its just bare bones updates from here on out. You get some html once and your done. Cache it and all you ever do from there on out is download posts. (granted posts don't cache so I'll chuck that on my todo list.\n\nAlso all of the cool browser bar stuff from the first engine is gone. There's also no more searching. Ill fix that later.","tags":"","time":1332487876118,"title":"New bloging engine."},{"blurb":"For the past while I've been thinking on how to speed up mobile websites. These are some notes that I have to make mobile web faster. ","body":"<h4> Cache Ajax </h4>\nWhen loading a site it may be useful to cache the Ajax response to html5 local storage. This allows the page to load old content before new content is delivered  resulting in perceived speed improvement (although not an actual speed improvent as we now have to pull from storage before we display new stuff). My current temptation is to start an Ajax request, THEN load cache and finally display what ever we get from the server. \n\nSo far that's all I got. My next thoughts are on how to decrease the latenency between the server and the phone. All that stuff the carriers put in to get the phone to go online ends up adding some odd 300ms to the round-trip time. If i can start the Ajax request early i can get a responce and render it as soon as the phone is ready rather than requesting after we have already rendered.  \n\nMore on this later.\n-Nick ","tags":"","time":1332537754846,"title":"Speeding up mobile (notes)"},{"blurb":"<p>There is a horrific lack of good OpenGl ES 2.0 Tutorials on the Internet\nfor Android. I'm going to try to rectify this problem by posting \neach and every step that I've done in my own work. </p>","body":"<p> Our vertex shader should be changed to look like this:</p>\n<pre><code class=\"cpp\">\n\"attribute vec4 vPosition;\\n\"\n\"attribute vec4 SourceColor;\\n\"\n\"varying vec4 DestinationColor;\\n\"\n\"uniform mat4 modelViewMatrix;\\n\"\n\"void main() {\\n\"\n\"DestinationColor = SourceColor;\\n\"\n\"    gl_Position = modelViewMatrix * vPosition;\\n\"\n\"}\\n\"\n</code> </pre>\n<p>\nvPosition will be the position of our verticies in our world. We are going to pass these in one by one using OpenGl's built in functions. Don't worry its only a couple of lines of code.\n<br>\nSourceColor is the color of each verticie that we pass in. So when we pass in the position of our vert we will we also pass in its color. This will eventually change but for now we want solid coloring on our verts.\n<br>\nDestinationColor is simply going to be piping down SourceColor into our fragment shader. More on this in a bit.\n<br>\nmodelViewMatrix is going to be very important. It will basically tell the shader exactly how we want to draw our geometry. This will be its own section.\n</p>\n<p> GLSL (our shader language) is very similar to C so everything goes into our main function. Inside that main we have two things DestinationColor and gl_Position. I already explained DestinationColor. gl_Position is one of the outputs of the shader. It's how we explain to the graphics card where we think this verticie is. modelViewMatrix is going to linearly transform vPosition so that we can rotate, scale, translate all of the verticies at once. The end result is that we rotate our entire world.</p>\n\n<p>Our fragment shader is a little easier\n<pre><code class=\"cpp\">\n\n\"precision mediump float;\\n\"\n\"varying lowp vec4 DestinationColor;\\n\"\n\"void main() {\\n\"\n\"  gl_FragColor = DestinationColor;\\n\"\n\"}\\n\"\n</code> </pre><p>\nHere we are simply going to pipe DesinationColor as the output color (gl_FragColor). This shader is going to get much more complex by the time I'm done with all these tutorials.</p>\n\n<p>Now that we have our shaders in order we can start filling them out.\nFor the most part we will be dealing with our own code and the code inside setupGraphics() and Render(). Google's shader compilers are actually really good\nfor our purposes so we don't need to really edit anything. </p>\n<p>We need to make sure that the CPU and the graphics card are communicateing properly. And that they both know where certain variables inside our shaders are. We need to find position handles for each variable we will be passing in from the CPU to the GPU. We do this using glGetUniformLocation() and glGetAttributeLocation().\n<br>\nInside setupGraphics() add the following code somewhere AFTER gProgram = createProgram... or else you will get a null pointer error.\n\n<pre><code class=\"cpp\">\nmvp_a_positionHandle = glGetUniformLocation(gProgram, \"modelViewMatrix\");\n\ngvPositionHandle = glGetAttribLocation(gProgram, \"vPosition\");\n_colorSlot = glGetAttribLocation(gProgram, \"SourceColor\");\nglEnableVertexAttribArray(_colorSlot);\n\nLOGI(\"Found MVP Position Handle : %i\", mvp_a_positionHandle);\nLOGI(\"glGetAttribLocation(\\\"vPosition\\\") = %d\\n\",\n            gvPositionHandle);\ncheckGlError(\"glGetAttribLocation\");\nsetupVBO();\n</code> </pre><p>\n\nDon't forget to add some global variable declarations for mvp_a_positionHandle and _colorSlot both are of type GLuint.\n\n\n<br>\n<p>Now that we have the locations of our shader variables we need to initilize them. Since this code will change in the next tutorial go ahead and copy-paste this code ABOVE the setupGraphics() method.\n\n<pre><code class=\"cpp\">\ntypedef struct {<br/>\tfloat Position[3];<br/>\tfloat Color[4];<br/>} Vertex;\n<br>\nconst Vertex Vertices[] = {<br/>\t{{1, -1, 0}, {1, 0, 0, 1}},<br/>\t{{1, 1, 0}, {1, 0, 0, 1}},<br/>\t{{-1, 1, 0}, {0, 1, 0, 1}},<br/>\t{{-1, -1, 0}, {0, 1, 0, 1}},<br/>\t{{1, -1, -1}, {1, 0, 0, 1}},<br/>\t{{1, 1, -1}, {1, 0, 0, 1}},<br/>\t{{-1, 1, -1}, {0, 1, 0, 1}},<br/>\t{{-1, -1, -1}, {0, 1, 0, 1}}<br/>};<br/><br/>const GLubyte Indices[] = {<br/>\t// Front<br/>\t0, 1, 2,<br/>\t2, 3, 0,<br/>\t// Back<br/>\t4, 6, 5,<br/>\t4, 7, 6,<br/>\t// Left<br/>\t2, 7, 3,<br/>\t7, 6, 2,<br/>\t// Right<br/>\t0, 4, 1,<br/>\t4, 1, 5,<br/>\t// Top<br/>\t6, 2, 1, <br/>\t1, 6, 5,<br/>\t// Bottom<br/>\t0, 3, 7,<br/>\t0, 7, 4    <br/>};<br/>void setupVBO(){<br/><br/>\tGLuint vertexBuffer;<br/>\tglGenBuffers(1, &amp;vertexBuffer);<br/>\tglBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);<br/>\tglBufferData(GL_ARRAY_BUFFER, sizeof(Vertices), Vertices, GL_STATIC_DRAW);<br/><br/>\tGLuint indexBuffer;<br/>\tglGenBuffers(1, &amp;indexBuffer);<br/>\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indexBuffer);<br/>\tglBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(Indices), Indices, GL_STATIC_DRAW);<br/>}\n</code> </pre><p>\nThis is simply our cube and indices. But we're not done. We need to set up our vertex buffer objects. These are just going to make it easy to pass vertex data into our shader variables. For now we will copy-paste this code in. Next tutorial we will take a closer look at this and fix this code to handle models.\n<br>\n<pre><code class=\"cpp\">\nvoid setupVBO(){<br/><br/>\tGLuint vertexBuffer;<br/>\tglGenBuffers(1, &amp;vertexBuffer);<br/>\tglBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);<br/>\tglBufferData(GL_ARRAY_BUFFER, sizeof(Vertices), Vertices, GL_STATIC_DRAW);<br/><br/>\tGLuint indexBuffer;<br/>\tglGenBuffers(1, &amp;indexBuffer);<br/>\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indexBuffer);<br/>\tglBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(Indices), Indices, GL_STATIC_DRAW);<br/>}\n</code> </pre>\n<p>\nNow that we have that mess out of the way lets go ahead and set up that Model View Projection Matrix we were talking about. For those that don't know. When we take a vector (such as a coordinate in 3d space) and multiply it by a specific matrix we can move that coordinate into another point in 3d space. If we use the same matrix on a group of coordinates that make up a shape we effectively moved the entire shape around the space. Makeing this Model View Matrix is not simple but is time consumeing. You also need to have a good understanding of Linear Algebra to construct these. Good news though, pleanty of people have created libraries that will do exactly what we need. GLM is one such library and works well with android. \n<br>\n<a href=\"http://glm.g-truc.net/\">Download GLM here</a>\n<br>\nExtract the entire contents of the archive into the jni folder of your project. we need them for this section. \n</p>\n<p>\nThankfully GLM provide us with a Model View Projection Matrix function in their manual. For now this is going to be good enough. Paste these headers into your document \n<br>\n<pre><code class=\"cpp\">\n#include&lt;glm/glm.hpp&gt;<br>\n#include&lt;glm/gtc/matrix_transform.hpp&gt;<br>\n#include&lt;glm/gtc/type_ptr.hpp&gt;<br>\n</code> </pre><p>\nand then add this function somewhere above renderFrame().\n<br><pre><code class=\"cpp\">\nvoid setUniformMVP( GLuint Location, glm::vec3 const &amp; Translate, glm::vec3 const &amp; Rotate )<br/>{<br/>\tglm::mat4 Projection =<br/>\t\tglm::perspective(45.0f, 4.0f / 3.0f, 0.1f, 100.f);<br/>\tglm::mat4 ViewTranslate = glm::translate(<br/>\t\t\tglm::mat4(1.0f),<br/>\t\t\tTranslate);<br/>\tglm::mat4 ViewRotateX = glm::rotate(<br/>\t\t\tViewTranslate,<br/>\t\t\tRotate.y, glm::vec3(-1.0f, 0.0f, 0.0f));<br/>\tglm::mat4 View = glm::rotate(<br/>\t\t\tViewRotateX,<br/>\t\t\tRotate.x, glm::vec3(0.0f, 1.0f, 0.0f));<br/>\tglm::mat4 Model = glm::scale(<br/>\t\t\tglm::mat4(1.0f),<br/>\t\t\tglm::vec3(0.5f));<br/>\tglm::mat4 MVP = Projection * View * Model;<br/>\tglUniformMatrix4fv(<br/>\t\t\tLocation, 1, GL_FALSE, glm::value_ptr(MVP));}\n</code> </pre><p>\n\nThis will create our Model View Projection Matrix for us. But lets look at how it works. The function accepts Location as one of its parameters. This is going to be the location of modelViewMatrix inside our vertex shader. The translate method that it will take it will move our scene around the map. think of this as the offset method that will offset our cube to the left or right some pixels.\nrotate will do exactly what it sounds like. It will rotate our scene by some units in the given directions. </p>\n\n<p>\nNow we put it all together.  Go ahead an erase EVERYTHING in your renderFrame() method. And replace it with this:<br>\n<br><pre><code class=\"cpp\">\n\tglClearColor(0,0,0, 1.0f);<br/>\tcheckGlError(\"glClearColor\");<br/>\tglClear( GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);<br/>\tglEnable(GL_DEPTH_TEST);<br/>\tcheckGlError(\"glClear\");<br/><br/>\tglUseProgram(gProgram);<br/>\tcheckGlError(\"glUseProgram\");<br/><br/>\trotate =0.5f;<br/><br/>\tsetUniformMVP(mvp_a_positionHandle, glm::vec3(0,0,-3), glm::vec3(rotate,0,0));<br/><br/>\tglVertexAttribPointer(gvPositionHandle, 3, GL_FLOAT, GL_FALSE,<br/>\t\t\tsizeof(Vertex), 0);<br/>\tcheckGlError(\"glVertexAttribPointer\");<br/>\tglVertexAttribPointer(_colorSlot, 4, GL_FLOAT, GL_FALSE,<br/>\t\t\tsizeof(Vertex), (GLvoid*) (sizeof(float) * 3));<br/>\tcheckGlError(\"glVertexAttribPointer\");<br/>\tglEnableVertexAttribArray(gvPositionHandle);<br/>\tglDrawElements(GL_TRIANGLES, sizeof(Indices)/sizeof(Indices[0]),<br/>\t\t\tGL_UNSIGNED_BYTE, 0);<br/>\tcheckGlError(\"glDrawElements\");<br>\n<br></code> </pre><p>\n\nThis is the important part so lets go over what it does.<p>\n<p><b>glClearColor(0,0,0,1.0f);</b><br>\nThis simply makes our entire screen black. A good way to check for problems in rendering is to change this to a different color (say red) and see if it renders red. If it doesn't you have a problem with your frame buffers.\n</p>\n<p><b>glClear( GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);</b><br>\nThis tells the gpu to clear the depth buffer as well as the color buffer. \nWithout this we would keep drawing over the previous frame.</p>\n<p><b>glEnable(GL_DEPTH_TEST);</b><br>\nThis actually makes sure that we don't draw stuff in the background as the foreground. Go ahead and comment out this line and try this code without it. You'll see what I mean.</p>\n<p><b>setUniformMVP(mvp_a_positionHandle, glm::vec3(0,0,-3), glm::vec3(rotate,0,0));</b><br>\nThis is the function we added a bit ago. Here we are telling it the location of modelViewMatrix and passing in two vectors. Since the camera is always looking down the negative Z axis we push the scene back down the Z axis to zoom out a little. We also tell it to rotate the entire scene on the X axis.</p>\n<p><b>glVertexAttribPointer(gvPositionHandle, 3, GL_FLOAT, GL_FALSE,<br/>\t\t\tsizeof(Vertex), 0);<br/>\nglVertexAttribPointer(_colorSlot, 4, GL_FLOAT, GL_FALSE,<br/>\t\t\tsizeof(Vertex), (GLvoid*) (sizeof(float) * 3));<br/></b><br>\nThis line we are pointing our where we would like the verticies stored and telling the GPU that our verticies are defined by 3 numbers. We also tell the GPU what our array construction looks like. Each number is a GL_FLOAT and each element in our array is the size of a Vertex (the structure we declaired) and our array starts at 0; The next line does the same thing but for our color information.</p>\n<p><b>lDrawElements(GL_TRIANGLES, sizeof(Indices)/sizeof(Indices[0]),<br/>\t\t\tGL_UNSIGNED_BYTE, 0);<br/></b><br>\nHere is where we actually tell the GPU to draw each individual vert. We tell it to draw triangles and exactly how to draw the triangles. We tell it how to use the indice buffer we passed in. </p>\n<p>Thats it for now. I hope it helps, The next tutorial we will change our simple cube to a more complicated monkey face</p>","tags":"android opengl","time":1334590368135,"title":"Android Native OpenGL 2.0 Tutorial Part 1"},{"blurb":"<p>From part 1 we got the default project to work. This time we will go through \na little more and get a spinning cube. </p>\n\n<p>First lets start with our shaders. For now we will leave them hard coded inside the gl_code.cpp. Later on it will be wise to move them into a seperate file. </p>","body":"<p> Our vertex shader should be changed to look like this:</p>\n<pre><code class=\"cpp\">\n\"attribute vec4 vPosition;\\n\"\n\"attribute vec4 SourceColor;\\n\"\n\"varying vec4 DestinationColor;\\n\"\n\"uniform mat4 modelViewMatrix;\\n\"\n\"void main() {\\n\"\n\"DestinationColor = SourceColor;\\n\"\n\"    gl_Position = modelViewMatrix * vPosition;\\n\"\n\"}\\n\"\n</code> </pre>\n<p>\nvPosition will be the position of our verticies in our world. We are going to pass these in one by one using OpenGl's built in functions. Don't worry its only a couple of lines of code.\n<br>\nSourceColor is the color of each verticie that we pass in. So when we pass in the position of our vert we will we also pass in its color. This will eventually change but for now we want solid coloring on our verts.\n<br>\nDestinationColor is simply going to be piping down SourceColor into our fragment shader. More on this in a bit.\n<br>\nmodelViewMatrix is going to be very important. It will basically tell the shader exactly how we want to draw our geometry. This will be its own section.\n</p>\n<p> GLSL (our shader language) is very similar to C so everything goes into our main function. Inside that main we have two things DestinationColor and gl_Position. I already explained DestinationColor. gl_Position is one of the outputs of the shader. It's how we explain to the graphics card where we think this verticie is. modelViewMatrix is going to linearly transform vPosition so that we can rotate, scale, translate all of the verticies at once. The end result is that we rotate our entire world.</p>\n\n<p>Our fragment shader is a little easier\n<pre><code class=\"cpp\">\n\n\"precision mediump float;\\n\"\n\"varying lowp vec4 DestinationColor;\\n\"\n\"void main() {\\n\"\n\"  gl_FragColor = DestinationColor;\\n\"\n\"}\\n\"\n</code> </pre><p>\nHere we are simply going to pipe DesinationColor as the output color (gl_FragColor). This shader is going to get much more complex by the time I'm done with all these tutorials.</p>\n\n<p>Now that we have our shaders in order we can start filling them out.\nFor the most part we will be dealing with our own code and the code inside setupGraphics() and Render(). Google's shader compilers are actually really good\nfor our purposes so we don't need to really edit anything. </p>\n<p>We need to make sure that the CPU and the graphics card are communicateing properly. And that they both know where certain variables inside our shaders are. We need to find position handles for each variable we will be passing in from the CPU to the GPU. We do this using glGetUniformLocation() and glGetAttributeLocation().\n<br>\nInside setupGraphics() add the following code somewhere AFTER gProgram = createProgram... or else you will get a null pointer error.\n\n<pre><code class=\"cpp\">\nmvp_a_positionHandle = glGetUniformLocation(gProgram, \"modelViewMatrix\");\n\ngvPositionHandle = glGetAttribLocation(gProgram, \"vPosition\");\n_colorSlot = glGetAttribLocation(gProgram, \"SourceColor\");\nglEnableVertexAttribArray(_colorSlot);\n\nLOGI(\"Found MVP Position Handle : %i\", mvp_a_positionHandle);\nLOGI(\"glGetAttribLocation(\\\"vPosition\\\") = %d\\n\",\n            gvPositionHandle);\ncheckGlError(\"glGetAttribLocation\");\nsetupVBO();\n</code> </pre><p>\n\nDon't forget to add some global variable declarations for mvp_a_positionHandle and _colorSlot both are of type GLuint.\n\n\n<br>\n<p>Now that we have the locations of our shader variables we need to initilize them. Since this code will change in the next tutorial go ahead and copy-paste this code ABOVE the setupGraphics() method.\n\n<pre><code class=\"cpp\">\ntypedef struct {<br/>\tfloat Position[3];<br/>\tfloat Color[4];<br/>} Vertex;\n<br>\nconst Vertex Vertices[] = {<br/>\t{{1, -1, 0}, {1, 0, 0, 1}},<br/>\t{{1, 1, 0}, {1, 0, 0, 1}},<br/>\t{{-1, 1, 0}, {0, 1, 0, 1}},<br/>\t{{-1, -1, 0}, {0, 1, 0, 1}},<br/>\t{{1, -1, -1}, {1, 0, 0, 1}},<br/>\t{{1, 1, -1}, {1, 0, 0, 1}},<br/>\t{{-1, 1, -1}, {0, 1, 0, 1}},<br/>\t{{-1, -1, -1}, {0, 1, 0, 1}}<br/>};<br/><br/>const GLubyte Indices[] = {<br/>\t// Front<br/>\t0, 1, 2,<br/>\t2, 3, 0,<br/>\t// Back<br/>\t4, 6, 5,<br/>\t4, 7, 6,<br/>\t// Left<br/>\t2, 7, 3,<br/>\t7, 6, 2,<br/>\t// Right<br/>\t0, 4, 1,<br/>\t4, 1, 5,<br/>\t// Top<br/>\t6, 2, 1, <br/>\t1, 6, 5,<br/>\t// Bottom<br/>\t0, 3, 7,<br/>\t0, 7, 4    <br/>};<br/>void setupVBO(){<br/><br/>\tGLuint vertexBuffer;<br/>\tglGenBuffers(1, &amp;vertexBuffer);<br/>\tglBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);<br/>\tglBufferData(GL_ARRAY_BUFFER, sizeof(Vertices), Vertices, GL_STATIC_DRAW);<br/><br/>\tGLuint indexBuffer;<br/>\tglGenBuffers(1, &amp;indexBuffer);<br/>\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indexBuffer);<br/>\tglBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(Indices), Indices, GL_STATIC_DRAW);<br/>}\n</code> </pre><p>\nThis is simply our cube and indices. But we're not done. We need to set up our vertex buffer objects. These are just going to make it easy to pass vertex data into our shader variables. For now we will copy-paste this code in. Next tutorial we will take a closer look at this and fix this code to handle models.\n<br>\n<pre><code class=\"cpp\">\nvoid setupVBO(){<br/><br/>\tGLuint vertexBuffer;<br/>\tglGenBuffers(1, &amp;vertexBuffer);<br/>\tglBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);<br/>\tglBufferData(GL_ARRAY_BUFFER, sizeof(Vertices), Vertices, GL_STATIC_DRAW);<br/><br/>\tGLuint indexBuffer;<br/>\tglGenBuffers(1, &amp;indexBuffer);<br/>\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indexBuffer);<br/>\tglBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(Indices), Indices, GL_STATIC_DRAW);<br/>}\n</code> </pre>\n<p>\nNow that we have that mess out of the way lets go ahead and set up that Model View Projection Matrix we were talking about. For those that don't know. When we take a vector (such as a coordinate in 3d space) and multiply it by a specific matrix we can move that coordinate into another point in 3d space. If we use the same matrix on a group of coordinates that make up a shape we effectively moved the entire shape around the space. Makeing this Model View Matrix is not simple but is time consumeing. You also need to have a good understanding of Linear Algebra to construct these. Good news though, pleanty of people have created libraries that will do exactly what we need. GLM is one such library and works well with android. \n<br>\n<a href=\"http://glm.g-truc.net/\">Download GLM here</a>\n<br>\nExtract the entire contents of the archive into the jni folder of your project. we need them for this section. \n</p>\n<p>\nThankfully GLM provide us with a Model View Projection Matrix function in their manual. For now this is going to be good enough. Paste these headers into your document \n<br>\n<pre><code class=\"cpp\">\n#include&lt;glm/glm.hpp&gt;<br>\n#include&lt;glm/gtc/matrix_transform.hpp&gt;<br>\n#include&lt;glm/gtc/type_ptr.hpp&gt;<br>\n</code> </pre><p>\nand then add this function somewhere above renderFrame().\n<br><pre><code class=\"cpp\">\nvoid setUniformMVP( GLuint Location, glm::vec3 const &amp; Translate, glm::vec3 const &amp; Rotate )<br/>{<br/>\tglm::mat4 Projection =<br/>\t\tglm::perspective(45.0f, 4.0f / 3.0f, 0.1f, 100.f);<br/>\tglm::mat4 ViewTranslate = glm::translate(<br/>\t\t\tglm::mat4(1.0f),<br/>\t\t\tTranslate);<br/>\tglm::mat4 ViewRotateX = glm::rotate(<br/>\t\t\tViewTranslate,<br/>\t\t\tRotate.y, glm::vec3(-1.0f, 0.0f, 0.0f));<br/>\tglm::mat4 View = glm::rotate(<br/>\t\t\tViewRotateX,<br/>\t\t\tRotate.x, glm::vec3(0.0f, 1.0f, 0.0f));<br/>\tglm::mat4 Model = glm::scale(<br/>\t\t\tglm::mat4(1.0f),<br/>\t\t\tglm::vec3(0.5f));<br/>\tglm::mat4 MVP = Projection * View * Model;<br/>\tglUniformMatrix4fv(<br/>\t\t\tLocation, 1, GL_FALSE, glm::value_ptr(MVP));}\n</code> </pre><p>\n\nThis will create our Model View Projection Matrix for us. But lets look at how it works. The function accepts Location as one of its parameters. This is going to be the location of modelViewMatrix inside our vertex shader. The translate method that it will take it will move our scene around the map. think of this as the offset method that will offset our cube to the left or right some pixels.\nrotate will do exactly what it sounds like. It will rotate our scene by some units in the given directions. </p>\n\n<p>\nNow we put it all together.  Go ahead an erase EVERYTHING in your renderFrame() method. And replace it with this:<br>\n<br><pre><code class=\"cpp\">\n\tglClearColor(0,0,0, 1.0f);<br/>\tcheckGlError(\"glClearColor\");<br/>\tglClear( GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);<br/>\tglEnable(GL_DEPTH_TEST);<br/>\tcheckGlError(\"glClear\");<br/><br/>\tglUseProgram(gProgram);<br/>\tcheckGlError(\"glUseProgram\");<br/><br/>\trotate =0.5f;<br/><br/>\tsetUniformMVP(mvp_a_positionHandle, glm::vec3(0,0,-3), glm::vec3(rotate,0,0));<br/><br/>\tglVertexAttribPointer(gvPositionHandle, 3, GL_FLOAT, GL_FALSE,<br/>\t\t\tsizeof(Vertex), 0);<br/>\tcheckGlError(\"glVertexAttribPointer\");<br/>\tglVertexAttribPointer(_colorSlot, 4, GL_FLOAT, GL_FALSE,<br/>\t\t\tsizeof(Vertex), (GLvoid*) (sizeof(float) * 3));<br/>\tcheckGlError(\"glVertexAttribPointer\");<br/>\tglEnableVertexAttribArray(gvPositionHandle);<br/>\tglDrawElements(GL_TRIANGLES, sizeof(Indices)/sizeof(Indices[0]),<br/>\t\t\tGL_UNSIGNED_BYTE, 0);<br/>\tcheckGlError(\"glDrawElements\");<br>\n<br></code> </pre><p>\n\nThis is the important part so lets go over what it does.<p>\n<p><b>glClearColor(0,0,0,1.0f);</b><br>\nThis simply makes our entire screen black. A good way to check for problems in rendering is to change this to a different color (say red) and see if it renders red. If it doesn't you have a problem with your frame buffers.\n</p>\n<p><b>glClear( GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);</b><br>\nThis tells the gpu to clear the depth buffer as well as the color buffer. \nWithout this we would keep drawing over the previous frame.</p>\n<p><b>glEnable(GL_DEPTH_TEST);</b><br>\nThis actually makes sure that we don't draw stuff in the background as the foreground. Go ahead and comment out this line and try this code without it. You'll see what I mean.</p>\n<p><b>setUniformMVP(mvp_a_positionHandle, glm::vec3(0,0,-3), glm::vec3(rotate,0,0));</b><br>\nThis is the function we added a bit ago. Here we are telling it the location of modelViewMatrix and passing in two vectors. Since the camera is always looking down the negative Z axis we push the scene back down the Z axis to zoom out a little. We also tell it to rotate the entire scene on the X axis.</p>\n<p><b>glVertexAttribPointer(gvPositionHandle, 3, GL_FLOAT, GL_FALSE,<br/>\t\t\tsizeof(Vertex), 0);<br/>\nglVertexAttribPointer(_colorSlot, 4, GL_FLOAT, GL_FALSE,<br/>\t\t\tsizeof(Vertex), (GLvoid*) (sizeof(float) * 3));<br/></b><br>\nThis line we are pointing our where we would like the verticies stored and telling the GPU that our verticies are defined by 3 numbers. We also tell the GPU what our array construction looks like. Each number is a GL_FLOAT and each element in our array is the size of a Vertex (the structure we declaired) and our array starts at 0; The next line does the same thing but for our color information.</p>\n<p><b>lDrawElements(GL_TRIANGLES, sizeof(Indices)/sizeof(Indices[0]),<br/>\t\t\tGL_UNSIGNED_BYTE, 0);<br/></b><br>\nHere is where we actually tell the GPU to draw each individual vert. We tell it to draw triangles and exactly how to draw the triangles. We tell it how to use the indice buffer we passed in. </p>\n<p>Thats it for now. I hope it helps, The next tutorial we will change our simple cube to a more complicated monkey face</p>","tags":"android opengl ndk","time":1334590441668,"title":"Android Native OpenGL 2.0 Tutorial Part 2"},{"blurb":"If you tell some poor nerd \"its OK to be weird, it gets better in a few years\" that doesn't change the fact that, for a 14 yo kid, graduation and college seems like a life-time away. But we can do better than \"oh woe is me\". High school doesn't have to be a drag.","body":"</p><p>\nBut lets be honest, being the odd man out has some perks, as long as you use them to your advantage. \n</p><p>\nFirst, you have no social life. GREAT! Use that free time for something worth while. Learn to program, learn to draw, learn to play video games better and then start a hit online series.  Don't wallow in pity. Get out there and start to do things.\n</p><p>\nOh, lets not forget, no one likes you. Wonderful! So we have nothing to lose. Go out and talk to people. Specifically, who ever you are interested in. That cute girl/boy across from you in biology. Ya. That one. Go ask them out. Whats the worst that could happen? Seriously, learning to talk to people in high school will make you much better off when college starts. Also read \"How to Win Friends and Influence People\" by Dale Carnegie. It will make your life much easier in college and may win you some good friend from high school. Because, who knows, maybe they'll say yes.\n</p><p>\nNext, To all those jerks who keep calling you names, one medium cafe late, extra cream.\n</p><p> Of those people who were making a fool of me in high school, are now making a fool of themselves in college. \"You majored in political science, and your qualifications include, 'Associate' at 'Nick's Coffee and Tea'\" I can imagine their future employers saying, \"Ya, I think we will stick with the guy that did a semester in the senators office\". Their habits in high school of not embracing diversity never offered them the perspective they needed to understand what other people were doing and what their competition looks like. Now, they are stuck because that one nerd from high school, who would spend hours in the debate classroom, who looked so stupid back then, just snagged a job from them. It's not quite, 'keep your friends close and your enemies closer', it's more about sharing common knowledge. A group of different people, with similar interests, will gather different knowledge and can, as a group, determine the state of affairs better than a single person or a group of similar people can. \n</p><p>\nWhich brings me to my final point, join a community. It doesn't matter what community. Be it a Minecraft server, some sub-reddit with a few thousand people, or local, join something. Get out there and expand your own horizons. If you are one of the lucky kids with parent that let you out of the house, go and visit conventions. Otherwise, be a part of something online. It doesn't matter what the community is, how it is structured, or who's in it. As long as its not a single homogeneous body, its good enough.\n\ntl;dr: Get a hobby, Talk to people. </p>","tags":"","time":1335291390807,"title":"High school doesn't have to suck if you're weird. "},{"title":"Native, Web-views, and Hybridizing.","blurb":"There is no one way to build a good app, but there are painful ways and there are easy ways. WebViews and Web apps are fantastic ways to quickly build cross platform apps but can be slow and clunky. Native apps prove to be difficult to maintain across versions. Hybridizing seems to be the way to go.","body":"<p> Heres what I've found from trying out some hybrid techniques for android. </p>\n<h3> JavaScript for view control, Native for data </h3>\n<p> Facebook famously moved their entire app from webviews to native after customer complaints about their app running slowly. While I have no knowledge of how they were running their application, I can say that from my experience purely JavaScript apps don't work. You need to at least move the data collection and network to the native code. This doesn't make it nearly as portable but the speed increase of native over JavaScript  is worth the extra effort.</p>\n\n<p> <a href = \"http://developer.android.com/guide/webapps/webview.html#UsingJavaScript\">Android allows you to make JavaScript calls directly to Java. </a> Using this makes for much cleaner JavaScript code and allows for Java to handle heavy lifting like netcode and image processing. </p>\n\n<h3> HTML for complex layouts </h3> \n<p>What I'm sticking with for now is to use HTML for complex layouts and use native Java for view control and data processing. This, so far, has been the most successful practice because it allows me to avoid copious amounts of XML and android style layouts while still being able to create and construct layouts of  varying complexity. I've found that using this delegation, it becomes possible to have views that all function independently of one another creating module layouts much cleaner.</p>\n<p>\nThe gist of this technique is to create a new WebView for each major component of the UI and inject the HTML into the WebView. The HTML can be completely self-contained and have its own navigation without the need to create the navigation using Android's APIs.\nI try to avoid heavy JavaScript inside these WebViews except for some animations and event firing.</p> \n\n<p> This technique works wonders for \"shotgun UI\" or lots of small little pieces of UI all stuck together. Android requires far more code per piece of UI than HTML and for lots of little trinkets and buttons  HTML becomes a life saver. </p>\n\nMore on this as it develops.","tags":"Android","time":1342387641012},{"title":"Contact Me","blurb":"Sometimes, people want to get in touch. So heres some contact info.","body":"<h3> Nick Tkachov </h3>\n<br>\n<h3> nick at thedailynerd.com </h3>\n<br><br>\n<p> I do apologize for not linking directly or including the @. But you have to understand that this is just a small step to preventing mass spam from flooding my inbox. </p>\n","tags":"contact me","time":1343180354431},{"title":"How I learned to pump out more features with less work. ","blurb":"This summer is the first summer I’ve spent doing work for someone other than myself. Previous summers, I’ve simply sat around the house and coded all day on a project I had come up with. But this summer, I’m part of an Amazon team with a serious spark in their eyes and a healthy appetite for things that need to get done and I’ve learned from them what the key is to getting things done. ","body":"<p>\nIf you’re reading for quick tips you best read elsewhere. The key to a higher output is not easy and it’s not quick. This is a process that has taken me 3 years of work and has only started to pay off. </p>\n<p>\nImproving my output was a conscious effort that was accomplished a by a few good principles that I focused my efforts on, having highly readable code which requires constant attention to the over-arching design and syntax consistency as well as good naming conventions and adherence to a strict set of rules. And reducing the amount of technical debt and lag that I take on.</p>\n<p>\nWithout always thinking about “where does this chunk of code fit in within the rest of my control flow” you’re bound to lose focus of what you’re actually doing and start working on tiny details. It doesn’t really matter if this is a for or a while loop, what matters is why are you looping in the first place and is there something you can change that will remove the loop? Sometimes changing one thing earlier in the control flow can reduce the amount of work that you need to do later on. Such as refactoring a series of injections rather than hacking around it all. And all of this is mute without always keeping the bigger picture in mind. </p>\n<p>\nHaving consistent syntax helps when reading code. It reduces complicated blocks of code to an almost visual language. If for loops and if / else always look the same then it becomes much clearer to see what is happening. Simple things like “if(isConnectionAlive())” vs. “if(!isConnectionClosed)” (not using negatives where they can be positives) and always using for loops instead of while loops makes following the logic easier. As tempting as it is to use syntactic sugar to make you look smarter, writing clean, clear, and bug free code is far more productive. It’s because of this, I try to avoid things like the ternary operator now. It lets me see from a distance what I’ve done and makes it easy for my team mates to see what I’ve done.\n</p>\n<p>\nNaming is incredibly important. I would rather name my methods stupidly long than to use a confusing name that is going to cause me to scratch my head and go “So what does this do again?”. Most good text editors and IDE’s have an autocomplete feature which will fill in the name for you so chances are you’ll never have to type it all out. There’s no reason to use names that aren’t descriptive. Furthermore, It often becomes useful to abstract entire chunks of logic with a simple name. Sure, maybe I only use this function in one place and it might be unnecessary but having a chunk of logic abstracted into “isPlayerInEndGoal()” makes it that much easier to see what the program is doing from a grander picture. </p>\n<p>\nI also have my own strict set of rules that I have developed over the years. Simple things like “never use static methods unless they are truly static because they make it harder to mock and test” [1], “If a line appears in more than one place, make it its own function”, “If an object is doing double duty, split it into two objects”. These little rules are just plain old good coding practice. Following them is important no matter how tempting it is to “just paste this one line right here”. </p>\n<p>\nBecause all of this leads into the most important rule and lesson I’ve learned so far. <b> Never take on any technical debt [2]. Ever. </b> Even though tech debt seems fine for the first few days, after two weeks you now have 2 weeks of bad code that has worked around and that’s two weeks worth of further debt. I make sure to pay all my debt as fast as a possible can and do everything in my power to avoid it in the first place because I need to be just as productive in a week as I am today. </p>\n<p>\nThis leads me to my final point, lag. Lag is the time that it takes between when I wake up and when I am productive. That time usually spent checking email, reading up on blogs and news. Any sort of self-gratifying-feeling-like-you’re-being-productive-but not-really morning routine that doesn’t involve consumer facing or user enhancing work. Because at the end of the day, the only thing that matters is what the user can use. And if it doesn’t help the user it doesn’t help me. The way I combat this is by making a mental note every night (sometimes a physical one) of what I have accomplished that day, and what I have to accomplish the next. This way when I wake up I don’t have to hunt around for work to do. I have a clear task in mind for this morning. By the time I’m done with that task, I will have found something else to do, or I will have a better idea of what I have to do for the next day. </p>\n\n<p>Lag also happens when you’re working on any feature or piece that doesn’t need to be worked on. Never write code that you don’t need at this very instant. Because if I don’t need it now, I won’t need it later. And if I do need it later, I’ll write it then. The amount of time that can be taken up writing nice-to-have code is infinite. And if it doesn’t impact the user, it doesn’t impact me.</p>\n<p>\nThis truly isn’t something that can be implemented tomorrow and see effects by the end of the week. Until one has their own set of rules, conventions, and everything involving code quality is second nature, one will not see any improvements in their work flow like I have. Only now that I’ve had the experience to know why good code is important and why good code quality makes for faster programming have I started to see the effects of little tweaks to my routine. Sure I could post about all the minutia like managing object dependencies and how it’s improved my productivity by X% but it won’t help anyone who hasn’t covered all of the other things that are slowing them down. </p>\n<p>\nAlso, don’t read any “productivity porn” or “productivity porn porn”. Seriously, get back to work. \n</p>\n[1] A truly static method (imho) is a function in the mathematical sense. It does not make any assignments, gives the same output for a given input and does not change its input in any way. Think Math.sqrt. <br>\n\n[2] Technical Debt is any time you put off refactoring something or write something with the intention of refactoring it later on. ","tags":"work faster","time":1343890131223},{"title":"Cuss: The Unused CSS Selector Scanner","blurb":"Cuss is a program I wrote to grab all of my silly CSS files and mark which CSS selectors I wasn't using. Usually after I'm done developing my websites I have a bunch of little CSS selectors that I haven't used. Cuss will notify you of all of these. Cuss will work with most css selectors detailed in CSS 3 including more complicated ones like child selectors. \n<br>\n<a  href=\"https://github.com/ntkachov/cuss\" class="link"> If you're interested, heres the github page </a>","body":"","tags":"cuss ","time":1344046474263}]
